// Binary Search 재귀 알고리즘 수두코드
//분할: 반으로 나눠서 찾고자하는 x가 mid보다 작으면 오른쪽을, 크면 왼쪽을 버림
//정복: 선택된 반쪽에서 x를 찾음
//병합: 無 - 원소 위치 찾는거라, 과거에 했던거 합칠 필요X    cf. merge sort에선, 분할, 정복, 통합 모두 有


index location (index low, index high) {	//
	if (low > high)     //역전되면
		return 0;
	else {              //아직 보지않은게 남아있음.
		mid = (low + high)
		if (x == S[mid])			//단위연산 (알고리즘 분석시)
			return mid;
		else if (x < S[mid])			//좌측 - 넘겨주는 매개변수값 바꿔가며
			return location(low, mid-1);
		else					//우측 - 넘겨주는 매개변수값 바꿔가며
			return location(mid+1, high);
	}
}
		
//호출
locationout = location(1,n)		


//----------------------------------------------------------------------------------------
// Binary Search 반복 알고리즘 수두코드 (재귀랑 구조==. 특히 뤂 탈출 조건)
void binSearch (int n, const keytype S[], keytype x, index& location) {
	index low, high, mid;
	low=1; high=n;
	location = 0;

	while (low <= high && location ==0) {    //cf. 재귀끝냄.
		mid = (low+high)/2;
		if (x == S[mid]) location mid;
		else if (x < S[mid]) high=mid-1;
		else low = mid+1;
	}
}


//----------------------------------------------------------------------------------------
/* memo
재귀호출로 변하지 않는 상수 변수는 넘기지 않음. 인덱스만 함수의 인자로.
  input인 'n, S[], x가 전역변수로 쓰여서' 가능하다. 변하지 않아서.  

cf. S배열 검색할 범위는 좁혀나가지만, S배열 자체는 그대로 존재함
  매번 재귀호출 일어날때마다, 콜러에서 S넘기고, 매개변수에 또 S있고
  = 변하지 않는 데이터를 계속 매달고 다니는 꼴 = bad
  
  
분할정복으로 재귀 알고리즘 개발시 주의할점!
  - 분할한 작은 입력사례의 답으로부터 -> 전체 입력사례의 답을 구하는 방법 
  - 더이상 분할 불가능한 입력사례 판단할 '종료조건' 구하기  (분할종료)
  - 종료조건 만족하는 경우 답 어떻게 구할지 정하기
  
  
꼬리 재귀호출 (tail recursion)
  - 재귀알고리즘에서, 모든 재귀호출이 알고리즘의 꼬리(끝)에서 이뤄질때
    = 호출 이후 더이상 연산이 없음
  - 반복 알고리즘으로 변환 good
    반복: 효율 굳   vs. 재귀: 호출할 때마다, 활성 레코드(activation records) 스택에 저장해야.
    ㄴ 단, 계산복잡도가 좋다는 의미X (반복알고리즘이 상수적으로만 좋다)
    ㄴ> 사람이 재귀쓰고, 대신에 효율을 위해 컴파일러가 쉽게 해줌


*/

/* 시간복잡도 분석
1. 최악경우 분석	//결론: Θ(lg n)
	단위연산: x와 S[mid]의 비교	//∵검색키와 배열 원소를 비교하는 연산 -> cost↑
	입력크기: 배열크기n (=high-low+1)
	
	<검색하게 될 반쪽 배열 크기가 항상 정확히 n/2되는 경우>	//반띵~
	  시간 복잡도 나타내주는 재현식(recurrence)
	
	  W(n) = W(n/2) + 1    n>1이고 2^k (k>=1)
	  W(1)= 1
	
	- 주먹구구식
	  W(1)=1
	  W(2)=W(1)+1=2
	  W(4)=W(2)+1=3
	  ...
	  W(2^k)=k+1
	  == W(n)=lg(n)+1∈Θ(lg(n))
	  
	- 수학적 귀납법	//주먹구구식을 체크하기 위한 방법
	  귀납 출발점: n=1이면, W(1)=1=lg1+1
	  귀납가정: W(n)=lg(n)+1
	  귀납단계: W(2n)=lg(2n)+1임을 보이기
		W(2n) = W(n) + 1	//재현식에 의해
		=lg(n)+1+1		//귀납가정 의해
		=lg(n)+lg2+1
		=lg(2n)+1
*/
